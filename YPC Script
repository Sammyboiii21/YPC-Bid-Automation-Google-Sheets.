function updateYPCSeenAndNewBids() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dailySheet = ss.getSheetByName("Daily Pull YPC");
  const seenSheet = ss.getSheetByName("Seen YPC");
  const newBidsSheet = ss.getSheetByName("New Bids YPC");

  dailySheet.activate();
  SpreadsheetApp.flush();

  const dailyData = dailySheet.getDataRange().getValues();
  const seenData = seenSheet.getDataRange().getValues();

  if (dailyData.length < 2) return;

  const headers = dailyData[0];
  const projectIdIndex = headers.indexOf("Project_ID");
  const projectLinkIndex = headers.indexOf("Project_Link");
  const projectNameIndex = headers.indexOf("Project");

  if (projectIdIndex === -1 || projectLinkIndex === -1 || projectNameIndex === -1) {
    throw new Error("Missing one or more required columns: Project_ID, Project_Link, or Project.");
  }

  const seenIDs = new Set(seenData.slice(1).map(row => String(row[projectIdIndex]).toUpperCase()));

  const newRows = dailyData.slice(1).filter(row =>
    !seenIDs.has(String(row[projectIdIndex]).toUpperCase())
  );

  const cleanedRows = newRows.map(row => {
    const cleaned = row.slice();
    cleaned[projectNameIndex] = {
      formula: `=HYPERLINK(\"${row[projectLinkIndex]}\", \"${row[projectNameIndex]}\")`
    };
    cleaned.splice(projectLinkIndex, 1);
    return cleaned;
  });

  const newHeaders = headers.slice();
  newHeaders.splice(projectLinkIndex, 1);

  // Force insert headers into row 1 of Seen YPC
  seenSheet.getRange(1, 1, 1, newHeaders.length).setValues([newHeaders]);

  // Append cleaned new rows below header
  if (cleanedRows.length > 0) {
    seenSheet.getRange(seenSheet.getLastRow() + 1, 1, cleanedRows.length, cleanedRows[0].length).setValues(
      cleanedRows.map(row => row.map(cell => typeof cell === 'object' && cell.formula ? cell.formula : cell))
    );
  }

  // Update New Bids YPC
  newBidsSheet.clearContents();
  newBidsSheet.getRange(1, 1, 1, newHeaders.length).setValues([newHeaders]);
  if (cleanedRows.length > 0) {
    newBidsSheet.getRange(2, 1, cleanedRows.length, cleanedRows[0].length).setValues(
      cleanedRows.map(row => row.map(cell => typeof cell === 'object' && cell.formula ? cell.formula : cell))
    );
  }

  // Construct email body using original newRows to avoid [object Object] issue
  const introLine = `<p>There are <strong>${newRows.length}</strong> new bids listed on Yakima Planning Center as of <strong>${new Date().toLocaleDateString()}</strong>.</p>`;

  const emailBody = newRows.map(row => {
    return newHeaders.map((header, idx) => {
      if (header === "Project") {
        return `<strong>Project:</strong> <a href="${row[projectLinkIndex]}">${row[projectNameIndex]}</a>`;
      }
      const originalIdx = idx >= projectLinkIndex ? idx + 1 : idx;
      return `<strong>${header}:</strong> ${row[originalIdx]}`;
    }).join('<br>');
  }).map(block => `<p>${block}</p>`).join('<hr>');

  const htmlBody = `
    <h3>New Bids from Yakima Planning Center</h3>
    ${introLine}
    ${emailBody}
  `;

  GmailApp.sendEmail(
    "Samuel.Kroll@cwu.edu",
    "New Bids from Yakima Planning Center",
    "",
    { htmlBody: htmlBody }
  );
}
